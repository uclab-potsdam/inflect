<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Mapbox Map with Hash Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100%;
    }
    #layer-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
      font-family: sans-serif;
    }
  </style>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Removed any Python-in-the-browser scripts (e.g., Pyodide, Brython) to prevent py.parse errors -->
  <!-- Add JSZip and togeojson for KMZ/KML support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.js"></script>
</head>
<body>
<div id="map"></div>
<div id="layer-controls"></div>
<script>
// Hide control panel if in an iframe
if (window.self !== window.top) {
  document.addEventListener('DOMContentLoaded', function() {
    var controls = document.getElementById('layer-controls');
    if (controls) controls.style.display = 'none';
  });
}
// Sample Mapbox access token (replace with your own for production)
mapboxgl.accessToken = 'pk.eyJ1IjoibXVzaG9uIiwiYSI6ImNtOGVhMWFkZTJqOGkyanI3aHJzaG11N3oifQ.gU_FaxkjsMZqUbFQedDSJA';

// Sample style
const style = 'mapbox://styles/mushon/cmg0uv6tl00jn01qy6ruzhg29';

// Layers to toggle (layer ids must exist in the style)
// Will be populated with all layers from the style after map load
let allStyleLayers = [];

// Will hold the style default visibility for each layer
const styleDefaultVisibility = {};

// Default camera
const defaultCamera = {
  center: [34.3537, 31.4238], // Custom view
  zoom: 10,
  bearing: 37.6,
  pitch: 0
};

// Parse hash: #lat,lng,zoom,bearing,pitch/+layer1,-layer2/load:filename.geojson/to:layer-id
function parseHash() {
  const hash = window.location.hash.replace('#', '');
  if (!hash) return { camera: { ...defaultCamera }, layers: allStyleLayers.map(l => l.id), loadFile: null, toLayer: null };
  // Allow load: anywhere, even as the only part of the hash
  let cameraStr = '', layersStr = '', loadFile = null;
  const parts = hash.split('/');
  // Find load: anywhere, remove it from parts
  const restParts = [];
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith('load:')) {
      loadFile = parts[i].slice(5).trim();
    } else if (parts[i].length > 0) {
      restParts.push(parts[i]);
    }
  }
  // If there are no restParts, still return valid defaults
  cameraStr = restParts[0] || '';
  layersStr = restParts[1] || '';
  const cameraParts = cameraStr ? cameraStr.split(',').map(Number) : [];
  // Parse layers: +layername means on, -layername means off
  let layersOn = allStyleLayers.map(l => l.id);
  if (layersStr) {
    // Start with all off, then apply toggles in order
    layersOn = [];
    // Process tokens in order, last toggle for each layer wins
    const layerState = {};
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+-])(.+)$/);
      if (!match) return;
      const [, sign, lname] = match;
      layerState[lname] = sign;
    });
    Object.entries(layerState).forEach(([lname, sign]) => {
      if (sign === '+') {
        layersOn.push(lname);
      }
      // '-' means keep it off (do not add)
    });
  }
  return {
    camera: {
      center: [cameraParts[1] || defaultCamera.center[0], cameraParts[0] || defaultCamera.center[1]],
      zoom: cameraParts[2] || defaultCamera.zoom,
      bearing: cameraParts[3] || defaultCamera.bearing,
      pitch: cameraParts[4] || defaultCamera.pitch
    },
    layers: layersOn,
    loadFile
  };
}

// Helper: load and add GeoJSON as top layer or replace source of a layer
async function loadAndAddOrReplaceGeoJSON(geojsonFile, toLayer) {
  try {
    const response = await fetch(geojsonFile);
    if (!response.ok) throw new Error('Failed to fetch GeoJSON');
    const geojson = await response.json();
    // Use the filename (without path) as the id for source and layer
    const fileId = geojsonFile.split('/').pop().replace(/[^a-zA-Z0-9_-]/g, '_');
    const sourceId = fileId;
    const layerId = fileId;
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    map.addSource(sourceId, { type: 'geojson', data: geojson });
    // Determine geometry type for default style
    let type = 'line';
    if (geojson.features && geojson.features.length) {
      const geomType = geojson.features[0].geometry && geojson.features[0].geometry.type;
      if (geomType === 'Polygon' || geomType === 'MultiPolygon') type = 'fill';
      else if (geomType === 'Point' || geomType === 'MultiPoint') type = 'circle';
    }
    const layerDef = {
      id: layerId,
      type,
      source: sourceId,
      layout: { visibility: 'visible' },
      paint: type === 'line' ? { 'line-color': '#f00', 'line-width': 3 } :
             type === 'fill' ? { 'fill-color': '#f00', 'fill-opacity': 0.5 } :
             { 'circle-radius': 6, 'circle-color': '#f00' }
    };
    map.addLayer(layerDef);
    // Add to allStyleLayers if not present
    if (!allStyleLayers.some(l => l.id === layerId)) {
      allStyleLayers.push({ id: layerId });
      styleDefaultVisibility[layerId] = 'visible';
    }
    // Always update layer controls to include the new layer, even if it's the only one
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    // Optionally fit bounds
    if (geojson.features && geojson.features.length) {
      const coords = geojson.features.flatMap(f => {
        if (!f.geometry) return [];
        if (f.geometry.type === 'LineString') return f.geometry.coordinates;
        if (f.geometry.type === 'Polygon') return f.geometry.coordinates.flat();
        if (f.geometry.type === 'MultiPolygon') return f.geometry.coordinates.flat(2);
        if (f.geometry.type === 'Point') return [f.geometry.coordinates];
        if (f.geometry.type === 'MultiPoint') return f.geometry.coordinates;
        return [];
      });
      if (coords.length) {
        const bounds = coords.reduce((b, c) => b.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
        map.fitBounds(bounds, { padding: 40, maxZoom: 16 });
      }
    }
    console.log('Loaded GeoJSON and added as default red layer:', geojsonFile);
  } catch (err) {
    alert('Error loading GeoJSON: ' + err.message);
    console.error(err);
  }
}

// Update hash from map state
function updateHash(map, visibleLayers) {
  const c = map.getCenter();
  const z = map.getZoom().toFixed(2);
  const b = map.getBearing().toFixed(1);
  const p = map.getPitch().toFixed(1);
  // Preserve existing layer part of hash if present
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
  if (layersStr !== undefined) {
    window.location.replace(`#${cameraStr}/${layersStr}`);
  } else {
    window.location.replace(`#${cameraStr}`);
  }
}

// Create layer controls
function createLayerControls(map, visibleLayers) {
  const container = document.getElementById('layer-controls');
  container.innerHTML = '<strong>Layers</strong><br>';
  let foundLayer = false;
  // Always reflect the current style visibility for checkboxes
  // Parse current hash for explicit toggles
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const explicitState = {};
  if (layersStr) {
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+-])(.+)$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
  }
  // Include all style layers and any geojson-above-* layers
  const allLayers = [
    ...allStyleLayers,
    ...map.getStyle().layers
      .filter(l => l.id.startsWith('geojson-above-') && !allStyleLayers.some(s => s.id === l.id))
      .map(l => ({ id: l.id }))
  ];
  allLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      foundLayer = true;
      const vis = map.getLayoutProperty(layer.id, 'visibility');
      const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
      let checked, bold, state, showReset = false;
      if (explicitState[layer.id] === '+') {
        checked = 'checked';
        bold = true;
        state = 'visible';
        showReset = (defaultVis !== 'visible');
      } else if (explicitState[layer.id] === '-') {
        checked = '';
        bold = true;
        state = 'hidden';
        showReset = (defaultVis !== 'none');
      } else {
        checked = (defaultVis === 'visible') ? 'checked' : '';
        bold = false;
        state = 'default';
        showReset = false;
      }
      const label = layer.name || layer.id;
      container.innerHTML += `<label style="${bold ? 'font-weight:bold;' : ''}"><input type="checkbox" data-layer="${layer.id}" ${checked}> ${label}</label>`;
      if (explicitState[layer.id]) {
        container.innerHTML += ` <button data-reset="${layer.id}" title="Reset to style default" style="font-size:1.1em;line-height:1;vertical-align:middle;padding:0 0.2em;">â†»</button>`;
      }
      container.innerHTML += '<br>';
    }
  });
  if (!foundLayer) {
    container.innerHTML += '<em>No toggleable layers found in the current style.</em>';
  }
  container.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() {
      const layerId = this.getAttribute('data-layer');
      if (!map.getLayer(layerId)) {
        console.warn(`Layer '${layerId}' not found in style.`);
        return;
      }
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
  const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+-])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Always toggle explicit + or -
      if (this.checked) {
        explicitState[layerId] = '+';
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      } else {
        explicitState[layerId] = '-';
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add reset button listeners
  container.querySelectorAll('button[data-reset]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-reset');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
  const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+-])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Restore style default
      const defaultVis = styleDefaultVisibility[layerId] || 'visible';
      map.setLayoutProperty(layerId, 'visibility', defaultVis);
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });
}

const { camera, layers } = parseHash();

const map = new mapboxgl.Map({
  container: 'map',
  style,
  center: camera.center,
  zoom: camera.zoom,
  bearing: camera.bearing,
  pitch: camera.pitch
});

map.on('load', () => {
  // Get all layers from the style
  allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id }));
  // Store the style default visibility for each layer
  allStyleLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
      let vis = 'visible';
      if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
        vis = styleLayer.layout.visibility;
      }
      styleDefaultVisibility[layer.id] = vis;
    }
  });
  // Only update the toggle list to reflect the current style visibility (do not use hash for initial state)
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  // Load GeoJSON if loadFile is present in the hash (as load:filename)
  const { loadFile } = parseHash();
  if (loadFile) {
    loadAndAddOrReplaceGeoJSON(loadFile + '.geojson');
  }
});

// Update hash on camera move
map.on('moveend', () => {
  // Only update camera part of hash, preserve layer toggles
  updateHash(map, []);
});

// Listen for hash changes (external navigation)
window.addEventListener('hashchange', () => {
  // Use parseHash to get camera, layers, and loadFile
  const { camera, layers, loadFile } = parseHash();
  // If allStyleLayers is empty (e.g. on direct hash change before map load), repopulate it
  if (!allStyleLayers.length) {
    allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id, name: l.name }));
    allStyleLayers.forEach(layer => {
      if (map.getLayer(layer.id)) {
        const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
        let vis = 'visible';
        if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
          vis = styleLayer.layout.visibility;
        }
        styleDefaultVisibility[layer.id] = vis;
      }
    });
  }
  // Animate camera, then apply layer changes halfway through
  const flyOpts = {
    center: [camera.center[0], camera.center[1]],
    zoom: camera.zoom,
    bearing: camera.bearing,
    pitch: camera.pitch,
    duration: 1200 // ms, can adjust as needed
  };
  map.flyTo(flyOpts);
  setTimeout(() => {
    // Set visibility for layers explicitly mentioned in the hash, and restore style default for others
    const layerState = {};
    if (layers) {
      layers.forEach(id => {
        layerState[id] = '+';
      });
    }
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const state = layerState[id];
      if (state === '+') {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'visible');
      } else if (state === '-') {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
      } else {
        if (map.getLayer(id)) {
          const defaultVis = styleDefaultVisibility[id] || 'visible';
          map.setLayoutProperty(id, 'visibility', defaultVis);
        }
      }
    });
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    // Load GeoJSON if loadFile is present in the hash (as load:filename)
    if (loadFile) {
      loadAndAddOrReplaceGeoJSON(loadFile + '.geojson');
    }
  // Do not reload the hardcoded GeoJSON file on hashchange to avoid infinite loop
  }, 600); // Halfway through the flyTo duration
});
</script>
</body>
</html>